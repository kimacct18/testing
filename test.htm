<!-- Generated by Harlequin Webmaker 2.0; Transducer 1.0.1 -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>vmspec: Java Virtual Machine Architecture</title>
</head>
<body>
<a name="HEADING4"></a>
<a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-1.html">Contents</a>       <a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-3.html">Prev</a>       <a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-5.html">Next</a>              <p>
</p><hr>
<a name="HEADING4-0"></a>
<h1>1	 Java Virtual Machine Architecture</h1>
<dl>
<dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-0"><b>1.1	</b> - Supported Data Types</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-12"><b>1.2	</b> - Registers</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-20"><b>1.3	</b> - Local Variables</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-24"><b>1.4	</b> - The Operand Stack </a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-36"><b>1.5	</b> - Execution Environment</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-57"><b>1.6	</b> - Garbage Collected Heap</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-59"><b>1.7	</b> - Method Area</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-61"><b>1.8	</b> - The Java Instruction Set</a></dt><dd>
</dd><dt><a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-4.html#HEADING4-69"><b>1.9	</b> - Limitations</a></dt><dd>
</dd></dl>

<a name="HEADING4-1"></a>
<hr>
<h2>1.1 Supported Data Types</h2>
The virtual machine data types include the basic data types of the Java language:<p>
</p><pre><code>byte  // 1-byte signed 2's complement integer
short  // 2-byte signed 2's complement integer
int  // 4-byte signed 2's complement integer
long  // 8-byte signed 2's complement integer
float  // 4-byte IEEE 754 single-precision float
double  // 8-byte IEEE 754 double-precision float
char  // 2-byte unsigned Unicode character</code>
</pre>
Nearly all Java type checking is done at compile time. Data of the 
primitive types shown above need not be tagged by the hardware to allow 
execution of Java. Instead, the bytecodes that operate on primitive 
values indicate the types of the operands so that, for example, the <code>iadd</code>, <code>ladd</code>, <code>fadd</code>, and <code>dadd</code> instructions each add two numbers, whose types are <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code>, respectively<p>
The virtual machine doesn't have separate instructions for <code>boolean</code> types. Intead, integer instructions, including integer returns, are used to operate on <code>boolean</code> values; <code>byte</code> arrays are used for arrays of <code>boolean</code>.</p><p>
The virtual machine specifies that floating point be done in IEEE 754 
format, with support for gradual underflow. Older computer architectures
 that do not have support for IEEE format may run Java numeric programs 
very slowly.</p><p>
Other virtual machine data types include:</p><p>
</p><pre><code>object  // 4-byte reference to a Java object
returnAddress  // 4 bytes, used with jsr/ret/jsr_w/ret_w instructions</code>
</pre>
<strong>Note:</strong> Java arrays are treated as objects.<strong></strong><p>
This specification does not require any particular internal structure 
for objects. In our implementation an object reference is to a handle, 
which is a pair of pointers: one to a method table for the object, and 
the other to the data allocated for the object. Other implementations 
may use inline caching, rather than method table dispatch; such methods 
are likely to be faster on hardware that is emerging between now and the
 year 2000.</p><p>
Programs represented by Java Virtual Machine bytecodes are expected to 
maintain proper type discipline and an implementation may refuse to 
execute a bytecode program that appears to violate such type discipline.</p><p>
While the Java Virtual Machines would appear to be limited by the 
bytecode definition to running on a 32-bit address space machine, it is 
possible to build a version of the Java Virtual Machine that 
automatically translates the bytecodes into a 64-bit form. A description
 of this transformation is beyond the scope of this specification.</p><p>
<a name="HEADING4-13"></a>
</p><hr>
<h2>1.2 Registers</h2>
At any point the virtual machine is executing the code of a single method, and the <code>pc</code> register contains the address of the next bytecode to be executed.<p>
Each method has memory space allocated for it to hold:</p><p>
</p><ul>
<li>a set of local variables, referenced by a <code>vars</code> register, <p>
</p></li><li>an operand stack, referenced by an <code>optop</code> register, and<p>
</p></li><li>a execution environment structure, referenced by a <code>frame</code> register.<p>
</p></li></ul>
All of this space can be allocated at once, since the size of the local 
variables and operand stack are known at compile time, and the size of 
the execution environment structure is well-known to the interpreter.<p>
All of these registers are 32 bits wide.</p><p>
<a name="HEADING4-21"></a>
</p><hr>
<h2>1.3 Local Variables</h2>
Each Java method uses a fixed-sized set of local variables. They are addressed as word offsets from the <code>vars</code> register. Local variables are all 32 bits wide. <p>
Long integers and double precision floats are considered to take up two 
local variables but are addressed by the index of the first local 
variable. (For example, a local variable with index <i>n</i> containing a double precision float actually occupies storage at indices <i>n</i> and <i>n</i>+1.)
 The virtual machine specification does not require 64-bit values in 
local variables to be 64-bit aligned. Implementors are free to decide 
the appropriate way to divide long integers and double precision floats 
into two words.</p><p>
Instructions are provided to load the values of local variables onto the
 operand stack and store values from the operand stack into local 
variables.</p><p>
<a name="HEADING4-25"></a>
</p><hr>
<h2>1.4 The Operand Stack </h2>
The machine instructions all take operands from an operand stack, 
operate on them, and return results to the stack. We chose a stack 
organization so that it would be easy to emulate the machine efficiently
 on machines with few or irregular registers such as the Intel 486.<p>
The operand stack is 32 bits wide. It is used to pass parameters to 
methods and receive method results, as well as to supply parameters for 
operations and save operation results.</p><p>
For example, the <code>iadd</code> instruction adds two integers 
together. It expects that the integers to be added are the top two words
 on the operand stack, pushed there by previous instructions. Both 
integers are popped from the stack, added, and their sum pushed back 
onto the operand stack. Subcomputations may be nested on the operand 
stack, and result in a single operand that can be used by the nesting 
computation. </p><p>
Each primitive data type has specialized instructions that know how to 
operate on operands of that type. Each operand requires a single 
location on the stack, except for <code>long</code> and <code>double</code>, which require two locations.</p><p>
Operands must be operated on by operators appropriate to their type. It is illegal, for example, to push two <code>int</code>s and then treat them as a <code>long</code>. This restriction is enforced, in the Sun implementation, by the bytecode verifier. However, a small number of operations (the <code>dup</code> opcodes and <code>swap</code>) operate on runtime data areas as raw values of a given width without regard to type.</p><p>
In our description of the virtual machine instructions below, the effect
 of an instruction's execution on the operand stack is represented 
textually, with the stack growing from left to right, and each 32-bit 
word separately represented. Thus:</p><p>
</p><pre>Stack: <i>..., <code>value1, value2 =&gt; ..., value3</code></i><p>
</p></pre>
shows an operation that begins by having <i>value2</i> on top of the stack with <i>value1</i> just beneath it. As a result of the execution of the instruction, <i>value1</i> and <i>value2</i> are popped from the stack and replaced by <i>value3</i>,
 which has been calculated by the instruction. The remainder of the 
stack, represented by an ellipsis, is unaffected by the instruction's 
execution.<p>
The types <code>long</code> and <code>double</code> take two 32-bit words on the operand stack:</p><p>
</p><pre>Stack: <i>... =&gt; ...,<code> value-word1, value-word2</code></i><p>
</p></pre>
This specification does not say how the two words are selected from the 64-bit <code>long</code> or <code>double</code> value; it is only necessary that a particular implementation be internally consistent.<p>
<a name="HEADING4-37"></a>
</p><hr>
<h2>1.5 Execution Environment</h2>
The information contained in the execution environment is used to do 
dynamic linking, normal method returns, and exception propagation.<p>
</p><h3>Dynamic Linking</h3>
The execution environment contains references to the interpreter symbol 
table for the current method and current class, in support of dynamic 
linking of the method code. The class file code for a method refers to 
methods to be called and variables to be accessed symbolically. Dynamic 
linking translates these symbolic method calls into actual method calls,
 loading classes as necessary to resolve as-yet-undefined symbols, and 
translates variable accesses into appropriate offsets in storage 
structures associated with the runtime location of these variables.<p>
This late binding of the methods and variables makes changes in other classes that a method uses less likely to break this code.</p><p>
</p><h3>Normal Method Returns</h3>
If execution of the current method completes normally, then a value is 
returned to the calling method. This occurs when the calling method 
executes a return instruction appropriate to the return type.<p>
The execution environment is used in this case to restore the registers 
of the caller, with the program counter of the caller appropriately 
incremented to skip the method call instruction. Execution then 
continues in the calling method's execution environment.</p><p>
</p><h3>Exception and Error Propagation</h3>
An exceptional condition, known in Java as an <code>Error</code> or <code>Exception</code>, which are subclasses of <code>Throwable</code>, may arise in a program because of:<p>
</p><ul>
<li>a dynamic linkage failure, such as a failure to find a needed class file,<p>
</p></li><li>a run-time error, such as a reference through a null pointer,<p>
</p></li><li>an asynchronous event, such as is thrown by <code>Thread.stop</code>, from another thread,<p>
</p></li><li>the program using a <code>throw</code> statement.<p>
</p></li></ul>
When an exception occurs:<p>
</p><ul>
<li>A list of catch clauses associated with the current method is examined. Each <code>catch</code>
 clause describes the instruction range for which it is active, 
describes the type of exception that it is to handle, and has the 
address of the code to handle it.<p>
</p></li><li>An exception matches a <code>catch</code> clause if the 
instruction that caused the exception is in the appropriate instruction 
range, and the exception type is a subtype of the type of exception that
 the <code>catch</code> clause handles. If a matching <code>catch</code>
 clause is found, the system branches to the specified handler. If no 
handler is found, the process is repeated until all the nested catch 
clauses of the current method have been exhausted.<p>
</p></li><li>The order of the <code>catch</code> clauses in the list is 
important. The virtual machine execution continues at the first matching
 catch clause. Because Java code is structured, it is always possible to
 sort all the exception handlers for one method into a single list that,
 for any possible program counter value, can be searched in linear order
 to find the proper (innermost containing applicable) exception handler 
for an exception occuring at that program counter value.<p>
</p></li><li>If there is no matching <code>catch</code> clause then the 
current method is said to have as its outcome the uncaught exception. 
The execution state of the method that called this method is restored 
from the execution environment, and the propagation of the exception 
continues, as though the exception had just occurred in this caller.<p>
</p></li></ul>
<h3>Additional Information</h3>
The execution environment may be extended with additional implementation-specific information, such as debugging information.<p>
<a name="HEADING4-58"></a>
</p><hr>
<h2>1.6 Garbage Collected Heap</h2>
The Java heap is the runtime data area from which class instances 
(objects) are allocated. The Java language is designed to be garbage 
collected -- it does not give the programmer the ability to deallocate 
objects explicitly. Java does not presuppose any particular kind of 
garbage collection; various algorithms may be used depending on system 
requirements.<p>
<a name="HEADING4-60"></a>
</p><hr>
<h2>1.7 Method Area</h2>
The method area is analogous to the store for compiled code in 
conventional languages or the text segment in a UNIX process. It stores 
method code (compiled Java code) and symbol tables. In the current Java 
implementation, method code is not part of the garbage-collected heap, 
although this is planned for a future release.<p>
<a name="HEADING4-62"></a>
</p><hr>
<h2>1.8 The Java Instruction Set</h2>
An instruction in the Java instruction set consists of a one-byte <i>opcode</i> specifying the operation to be performed, and zero or more <i>operands </i>supplying
 parameters or data that will be used by the operation. Many 
instructions have no operands and consist only of an opcode.<p>
The inner loop of the virtual machine execution is effectively:</p><p>
</p><pre><code>do {
    fetch an opcode byte
    execute an action depending on the value of the opcode
} while (there is more to do);</code>
</pre>
The number and size of the additional operands is determined by the 
opcode. If an additional operand is more than one byte in size, then it 
is stored in <em>big-endian</em> order -- high order byte first. For example, a 16-bit parameter is stored as two bytes whose value is: <p>
</p><pre><code>first_byte * 256 + second_byte</code>
</pre>
The bytecode instruction stream is only byte-aligned, with the exception being the <code>tableswitch</code> and <code>lookupswitch</code> instructions, which force alignment to a 4-byte boundary within their instructions.<p>
These decisions keep the virtual machine code for a compiled Java 
program compact and reflect a conscious bias in favor of compactness at 
some possible cost in performance.</p><p>
<a name="HEADING4-70"></a>
</p><hr>
<h2>1.9 Limitations</h2>
The per-class constant pool has a maximum of 65535 entries. This acts as
 an internal limit on the total complexity of a single class.<p>
The amount of code per method is limited to 65535 bytes by the sizes of 
the indices in the code in the exception table, the line number table, 
and the local variable table. This may be fixed for 1.0beta2.</p><p>
Besides this limit, the only other limitation of note is that the number
 of words of arguments in a method call is limited to 255.</p><p>
</p><hr>
<a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-1.html">Contents</a>       <a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-3.html">Prev</a>       <a href="http://web.mit.edu/java_v1.0.2/www/vmspec/vmspec-5.html">Next</a>              <p>

 </p></body></html>